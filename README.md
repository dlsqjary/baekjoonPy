인성질문
1.퇴사이유 : 원래부터 기술파트, R&D 부서에서 일하고 싶었고 SI가 잘 맞지 않는 것 같다고 느끼던 중에 연차 사용 관련해서 개인적으로 불만족스러운 여건이었음. 더 공부해보고 싶다는 생각도 있었기에 그때를 계기로 퇴사를 하게 됨.

2. 재입사 이유 : 퇴사하고 잠시 쉬고 다시 준비하려던 중 경제사정이 좋지 못하여 고민하다 다시 입사하게 됨.

3. 잘하는 것 / 관심있는 것...
웹 개발이랑은 관련없는데 아두이노를 활용해서 바른자세유지를 돕는 단말기를 만들 계획임.

4. 근무강도 : 정시퇴근이 힘들 수 있는데 괜찮은지? -> 괜찮음. 프로젝트도 수행하면서 야근하는 경우가 종종 있기 때문에 크게 상관X

5. 솔루션에 대한 내용
1) 모듈마다 다르긴 한데 가장 최신 업데이트가 5월11일로 알고 있음.
2) 솔루션 프로세스(구매프로세스)에 대해 하는가

6. R&D부서가 어떤 일을 하는 곳인지 아는지 
-> 프로젝트 수행 중이나 구축된 프로젝트에서 솔루션에 문제가 발견되거나 개선점이 파악되면 이를 수정하여 배포
-> 프로젝트 기술 지원
-> 최신기술 검토하여 솔루션에 적용

7. 지원사유
->입사했을 때부터 기술부에서 일하길 희망
->본인이 개발한 기능이 솔루션에 적용되어 사용되는 경험을 하길 희망함
->신입사원 교육때 원동명 책임님이 하신 말씀이 계속 기억에 남음: R&D팀은 수행팀, 기술지원팀에서 해결하지 못하는 것을 해결해야하는 부서다. 뒤가 없다. 라는 말이 멋있었고 그때부터 동경함.

8. R&D팀에 들어오면 개발해보고 싶은 것
->테스트간소화 도구(테스트데이터 자동입력)
->API문서 솔루션에 내재화
->소스 자동완성 기능

9. 지금까지 수행한 프로젝트
삼성물산건설, IBK시스템 EPRO구축, SOIL서버컨버전, GS리테일 구매포탈 인터페이스 변경

10. 개발하면서 문제가 있을 때 문제해결을 위해 어떻게 했는가?
->우선 로그, 에러 메세지 등을 분석하여 원인 파악 / 블로그, 온라인 문서 등을 통하여 관련 자료 검색 / 디버깅을 하며 프로그램 흐름을 체크하면서 문제 발생 원인 파악 + 문제 재현하며 원인 파악

11. 기억에 남는 프로젝트
-> IBK시스템 EPRO구축 / 보증보험 개발을 맡았는데 그 당시에 관련 지식도 부족하고 특정 공제조합과의 보증연계는 회사에서도 해본 사람이 많지 않아서 정보를 얻기가 힘들었음. 하지만 수많은 시행착오를 겪고 전공지식 등을 활용하면서 결국엔 개발을 끝마침.

12. 솔루션 개발하면서 아쉬웠던 점
원리를 모르고 사용하는 경우가 많다는게 아쉬움. 궁금할 때 소스를 따라가보면서 찾아보고는 있음.

궁금한 점
1. 부서에 들어가면 처음하게 될 업무는?
2. 오류나 개선사항이 발견되어 개발을 하고 테스트를 할 때 어떠한 환경에서 하는지?(환경을 동일하게 맞추고 하는지 데이터는 어떠한 방법으로 셋팅해서 넣는지)
3. 이번에 몇 명 정도 지원했는지, 결과는 언제 나오는지.
4. 10버전 개발에 R&D 인력이 얼마나 투입된건지.
5. 개발 환경이 어떻게 되는지(IDE 등..)



기술질문

1. 객체지향 5원칙
객체지향 프로그래밍(OOP)에서는 다음과 같은 다섯 가지 원칙, 즉 SOLID 원칙을 따르는 것이 중요합니다:

SRP (단일 책임 원칙, Single Responsibility Principle): 하나의 클래스는 단 하나의 책임을 가져야 합니다. 클래스는 변경의 이유가 하나여야 하며, 하나의 책임을 수정하기 위한 이유로 클래스를 변경하는 것을 원칙으로 합니다.

OCP (개방 폐쇄 원칙, Open-Closed Principle): 확장에는 열려있고 변경에는 닫혀있어야 합니다. 기존의 코드를 수정하지 않고도 기능을 확장할 수 있도록 설계해야 합니다. 이를 위해 추상화, 인터페이스, 상속 등을 활용합니다.

LSP (리스코프 치환 원칙, Liskov Substitution Principle): 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 합니다. 즉, 상속 관계에서 부모 클래스의 역할을 자식 클래스가 무결하게 수행할 수 있어야 합니다.

ISP (인터페이스 분리 원칙, Interface Segregation Principle): 클라이언트는 자신이 사용하지 않는 인터페이스에 의존해서는 안 됩니다. 인터페이스는 클라이언트가 필요로 하는 기능에 따라 작게 분리되어야 합니다.

DIP (의존성 역전 원칙, Dependency Inversion Principle): 추상화에 의존해야 하며, 구체화에 의존해서는 안 됩니다. 고수준 모듈은 인터페이스나 추상 클래스와 의존성을 맺어야 하며, 저수준 모듈은 추상화된 것에 의존해야 합니다.

이러한 SOLID 원칙을 준수하면 코드는 유지보수가 용이하고 확장성이 높아지며, 재사용성과 테스트 용이성이 향상됩니다. 이외에도 객체지향 설계 원칙에는 캡슐화, 상속, 다형성 등이 있으며, 이들을 적절히 활용하여 유연하고 효율적인 객체지향 프로그램을 구축할 수 있습니다.

2. 자바의 특징
1)이식성: JVM을 통해 운영체제에 구애받지 않고 동작
2)객체지향: 코드의 모듈화, 재사용성, 유지보수성 증가
3)가바지 컬렉터로 사용하지 않는 객체를 메모리에서 제거
4)다양한 라이브러리 사용가능

3. 추상클래스와 인터페이스의 차이
1)추상클래스: 일부 메서드가 구현되어 있음. 상수 필드 사용 가능, 필드, 생성자, 일반 메서드를 가질 수 있음
2)인터페이스: 모든 메서드는 추상 메서드로 선언되어 있음. 상수필드 사용 불가. 클래스가 구현해야 하는 내용을 정의
기능의 관련성, 일관성 중요: 인터페이스
공통기능 구현 : 추상 클래스

4.자바의 예외 처리 방법
try-catch   / throws 문:메서드 선언부에 throws 키워드를 사용하여 메서드에서 발생할 수 있는 예외를 선언합니다.예외가 발생한 경우, 해당 메서드를 호출한 곳에서 예외를 처리하도록 요구됩니다.

5. 오버로딩 / 오버라이딩 차이
->오버로딩: 같은 이름을 가진 메서드 여러 개 정의 / 매개변수의 순서, 타입, 갯수가 다름 / 메서드를 유연하게 사용 
->오버라이딩: 상위 클래스에서 정의된 메서드를 하위 클래스에서 동일한 이름으로 사용하여 '재정의'

6. 프로세스와 스레드의 차이
->프로세스: 일을 처리함에 있어서의 하나의 단위. 각 프로세스는 독립적
->스레드: 프로세스 내에 실행되는 작업의 단위. 스레드는 데이터와 자원을 공유함.

7. 자바 컬렉션

8. Array와 List의 차이
->Array: 한번 생성되면 크기 조절 불가 / 동일한 데이터 타입으로 요소들이 구성됨 / 연속된 메모리 공간에 저장, 속도가 빠름
->List: 크기가 동적으로 조절됨(ArrayList, LinkedList) / 다양한 데이터 타입 사용 가능 / 요소들이 메모리의 임의의 위치에 저장

9. OOP(객체지향프로그래밍) 특징
->캡슐화: 코드를 캡슐화하여 정보 은닉하고 데이터 접근을 제어 / 유지보수, 재사용성 향상
->상속: 클래스 간 계층 구조를 사용하여 코드를 재사용하고 유지보수성 증대
->다형성: 동일한 메서드나 인터페이스를 다른 방식으로 구현하게 함 / 코드의 유형성과 확장성이 향상
->추상화: 불필요한 부분을 덜고 필요한 부분만 뽑아내어 클래스나 인터페이스에 필요 기능, 속성 적용

10. 자바의 접근 제어자
public
가장 넓은 범위를 가지는 접근 제어자입니다.public으로 선언된 클래스, 멤버 변수, 메서드는 어디서든 접근이 가능합니다.다른 클래스에서 해당 멤버에 자유롭게 접근할 수 있으므로, 공용 인터페이스를 제공하는 데 사용됩니다.

protected:
같은 패키지 내에서는 public과 동일한 접근 범위를 가지지만, 다른 패키지의 클래스에서는 상속 관계에 있는 경우에만 접근이 가능합니다.protected로 선언된 멤버 변수, 메서드는 자식 클래스에서 접근이 가능합니다.상속과 관련된 클래스의 확장성과 유연성을 위해 사용됩니다.

default (package-private):
접근 제어자를 명시적으로 지정하지 않은 경우의 기본 접근 제어자입니다.같은 패키지 내에서만 접근이 가능하며, 다른 패키지에서는 접근할 수 없습니다.패키지 내에서 구성 요소를 은닉하고, 모듈 내부의 세부 구현을 감추는 데 사용됩니다.

private
가장 제한적인 접근 범위를 가지는 접근 제어자입니다.private으로 선언된 멤버 변수, 메서드는 외부에서 직접 접근할 수 없습니다.해당 멤버는 클래스 내부에서만 사용되고, 정보 은닉과 캡슐화를 위해 사용됩니다.접근 제어자는 클래스와 멤버의 가시성을 조절하여 캡슐화와 정보 은닉을 지원합니다. 적절한 접근 제어자를 사용하여 코드의 가독성과 유지보수성을 높일 수 있습니다.


11. 자바의 제네릭
제네릭을 사용하면 타입에 대한 일반화와 재사용성을 통해 코드의 가독성과 유지보수성을 향상시킬 수 있습니다. 또한 컴파일러의 타입 체크 기능을 활용하여 타입 안정성을 강화할 수 있습니다.

제네릭 -   클래스나 메소드를 컴파일 시 타입체크를 해주는 기능 -   객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환을 생략 -   C lass   Box   같은 형식으로 사용(Box 는 제네릭 클래스,  T는 타입 변수,   Box는 원시 타입)   /   private   T   item ;    같이 사용 -   Class   Box   V>   이렇게 멀티 타입 파라미터 사용가능 -   제네릭 메서드를 정의할 때 제네릭 타입에 대한 정의를 반드시 명시해야 함.   /   제네릭 클래스와 같은 클래스의 제네릭 메서드에 같은 타입파라미터를 사용하도 상관없음 -   와일드카드 '? ’  모든 타입가능.  S uper   / extends를 사용하여 조상,   자손만 되게 설정 가능 


12. 클래스 패스/ 클래스 로더 차이
클래스 패스  -   자바를 실행할 때,   클래스의 위치를 지정하는 역할 /   자바 컴파일러는 클래스가 다른 곳으로 이동하면 찾을 수 없는데 이때 필요한 것이 클래스 패스이다 -   클래스패스는 사용하는 클래스가 여러 경로에 분산되어 있을 때 사용한다. -   코드를 컴파일 할 때 클래스패스에 있는 jre 설정이 잘 못되어 있어 컴파일이 되지 않았던 경험이 있음.     

클래스 로더 -   실행 시에 필요한 클래스를 동적으로 메모리에 로드하는 역할 -   기존에 생성된 클래스 객체가 메모리에 존재하는지 확인하고 있으면 객체의 참조를 반환,   없으면 클래스 패스에 지정된 경로를 따라서 클래스 파일을 찾는다. 

13. 클래스 / 객체 / 인스턴스 
클래스:   객체를 정의해 놓은 틀 /   객체들의 유사한 속성을 묶어 놓은 것 

객체:   실제로 존재하는 사물이나 개념( ex:  스마트폰 자동차)  /  프로그래밍 관점에선 클래스에 정의된 내용대로 메모리에 생성된 것 

인스턴스 -   클래스로부터 객체를 만드는 과정을 인스턴스화 라고 함 -   어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 함 -   객체는 모든 인스턴스를 대표하는 포괄적인 의미. 
-   인스턴스는 어떤 클래스로부터 만들어진 곳인지를 강조하는 구체적인 의미 

14. String, StringBuffer, StringBuilder 차이
->String: 한번 생성된 문자열 변경 불가. 변경될 때마다 메모리 용량 증대됨
->StringBuffer: 가변형, 문자열 동적으로 변경 가능 / 문자열 변경될 때 내부 버퍼에서 처리하여 메모리 세이브 / 멀티스레드 환경에서 동기화(synchronized)된 메서드를 제공하여 스레드 안전성을 보장합니다. 
-> StringBuilder: 동기화 부분 빼고 StringBuffer랑 동일


신입 개발자 면접에서 나올 수 있는 스프링(Spring) 관련 질문 중 15개를 뽑아보았습니다. 각 질문에 대한 간단한 답변도 함께 제공해드리겠습니다:

스프링 프레임워크(Spring Framework)란 무엇인가요? 어떤 기능을 제공하나요?

스프링 프레임워크는 자바 기반의 오픈 소스 애플리케이션 개발 프레임워크입니다.스프링은 의존성 주입(Dependency Injection), 제어 역전(Inversion of Control), 애스펙트 지향 프로그래밍(Aspect-Oriented Programming) 등을 포함한 다양한 기능을 제공합니다.

스프링의 핵심 모듈은 어떤 것들이 있고, 각각의 역할은 무엇인가요?

스프링의 핵심 모듈에는 스프링 코어(Spring Core), 스프링 컨텍스트(Spring Context), 스프링 AOP(Spring AOP), 스프링 DAO(Spring DAO) 등이 있습니다.스프링 코어는 의존성 주입(Dependency Injection)과 제어 역전(Inversion of Control)을 담당합니다.스프링 컨텍스트는 애플리케이션의 라이프사이클 관리와 의존성 관리를 제공합니다.스프링 AOP는 애스펙트 지향 프로그래밍을 지원합니다.스프링 DAO는 데이터 액세스 계층의 개발을 지원합니다.

의존성 주입(Dependency Injection)이란 무엇인가요? 어떻게 동작하나요?

의존성 주입은 객체 간의 의존 관계를 외부에서 설정하여 객체들이 직접 의존 관계를 만들지 않고 외부에서 주입받는 것을 말합니다.스프링은 의존성 주입을 위해 @Autowired 어노테이션을 사용하거나 XML 또는 자바 설정 파일에서 의존 관계를 정의합니다.의존성 주입을 통해 객체 간의 결합도를 낮추고 코드의 유연성과 재사용성을 높일 수 있습니다.

컨테이너(Container)란 무엇인가요? 스프링에서 컨테이너의 역할은 무엇인가요?

컨테이너는 객체의 생성과 관리를 담당하는 런타임 환경을 말합니다.스프링 컨테이너는 스프링 프레임워크의 핵심이며, 스프링 애플리케이션의 라이프사이클을 관리하고 객체의 생성, 의존성 주입, 설정 등을 담당합니다.스프링 컨테이너는 ApplicationContext 인터페이스를 구현한 클래스들을 이용하여 생성하고, 스프링 빈을 관리합니다.

스프링의 빈(Bean)이란 무엇인가요? 어떻게 정의하고 사용하나요?

스프링의 빈은 스프링 컨테이너가 관리하는 객체를 말합니다.스프링에서 빈은 스프링 컨테이너에 등록되고, 의존성 주입을 받아서 사용됩니다.빈은 스프링의 설정 파일에서 정의되거나 어노테이션을 사용하여 정의할 수 있습니다.

스프링의 스코프(Scope)에는 어떤 것들이 있으며, 각각의 특징은 무엇인가요?

스프링의 스코프에는 싱글톤(Singleton), 프로토타입(Prototype), 요청(Request), 세션(Session), 글로벌 세션(Global Session) 등이 있습니다.싱글톤 스코프는 하나의 인스턴스만 생성되어 애플리케이션 전체에서 공유됩니다.프로토타입 스코프는 요청이 있을 때마다 매번 새로운 인스턴스를 생성합니다.요청 스코프는 웹 애플리케이션에서 각각의 HTTP 요청마다 인스턴스를 생성합니다.세션 스코프는 웹 애플리케이션에서 각각의 세션마다 인스턴스를 생성합니다.글로벌 세션 스코프는 포털 애플리케이션에서 사용되며, 각각의 글로벌 세션마다 인스턴스를 생성합니다.

스프링의 AOP(Aspect-Oriented Programming)은 무엇인가요? 어떻게 동작하나요?

AOP는 관점 지향 프로그래밍을 의미하며, 횡단 관심사(Cross-cutting Concern)를 모듈화하는 기법입니다.스프링의 AOP는 프록시를 사용하여 핵심 비즈니스 로직에 부가적인 기능을 추가합니다.AOP는 어노테이션 또는 XML 설정을 사용하여 포인트컷(Pointcut)과 어드바이스(Advice)를 정의합니다.

스프링의 트랜잭션(Transaction) 관리는 어떻게 이루어지나요?

스프링은 트랜잭션 관리를 위해 트랜잭션 추상화(Transaction Abstraction)를 제공합니다.트랜잭션은 @Transactional 어노테이션을 사용하거나 XML 설정에서 정의할 수 있습니다.스프링은 트랜잭션을 시작하고 커밋 또는 롤백하는 기능을 제공하여 데이터베이스 트랜잭션을 관리합니다.

스프링의 MVC(Model-View-Controller) 패턴은 무엇인가요? 어떻게 동작하나요?

스프링 MVC는 웹 애플리케이션 개발을 위한 모델-뷰-컨트롤러 패턴입니다.모델은 애플리케이션의 데이터와 비즈니스 로직을 담당하고, 뷰는 사용자에게 결과를 보여줍니다.컨트롤러는 요청을 처리하고 모델과 뷰를 조작하여 적절한 응답을 생성합니다.스프링 MVC는 @Controller 어노테이션과 요청 매핑(Request Mapping)을 사용하여 컨트롤러를 정의하고 동작합니다.

스프링의 RESTful 웹 서비스 개발을 위한 기능은 무엇인가요?

스프링은 RESTful 웹 서비스 개발을 위해 다양한 기능을 제공합니다.@RestController 어노테이션을 사용하여 RESTful 컨트롤러를 정의할 수 있습니다.@RequestMapping 어노테이션을 사용하여 요청 매핑을 지정하고, @PathVariable 어노테이션을 사용하여 경로 변수를 추출할 수 있습니다.@RequestBody 어노테이션을 사용하여 요청 바디의 데이터를 객체로 매핑할 수 있습니다.@ResponseBody 어노테이션을 사용하여 응답 데이터를 직접 출력할 수 있습니다.

스프링 시큐리티(Spring Security)는 무엇인가요? 어떻게 동작하나요?

스프링 시큐리티는 인증(Authentication)과 인가(Authorization)를 담당하는 보안 프레임워크입니다.스프링 시큐리티는 UserDetailsService 인터페이스를 구현하여 사용자 인증 정보를 제공합니다.설정 파일이나 어노테이션을 사용하여 URL별로 접근 권한을 설정할 수 있습니다.스프링 시큐리티는 폼 인증, 토큰 인증, OAuth 인증 등 다양한 인증 방식을 지원합니다.

스프링부트(Spring Boot)란 무엇인가요? 어떤 장점을 가지고 있나요?

스프링부트는 스프링 기반의 애플리케이션을 빠르고 쉽게 개발하기 위한 프레임워크입니다.스프링부트는 자동 구성과 컨벤션으로 인해 설정이 간소화되고, 내장된 서버를 사용하여 애플리케이션을 쉽게 실행할 수 있습니다.스프링부트는 의존성 관리를 자동으로 처리하고, 애플리케이션 모니터링과 관리를 위한 다양한 기능을 제공합니다.

스프링 데이터(Spring Data)는 무엇인가요? 어떤 기능을 제공하나요?

스프링 데이터는 데이터 액세스 계층의 개발을 쉽게 하기 위한 프로젝트입니다.스프링 데이터는 데이터베이스에 접근하기 위한 일반적인 기능을 제공하며, JPA, MongoDB, Redis 등 다양한 데이터 저장소를 지원합니다.스프링 데이터는 리포지토리 인터페이스를 정의하고, 메서드 네임 매칭이나 쿼리 어노테이션을 사용하여 데이터 액세스를 처리합니다.

스프링 부트와 스프링 클라우드(Spring Cloud)의 관계는 무엇인가요?

스프링 부트는 단일 마이크로서비스 애플리케이션을 빠르고 쉽게 개발하기 위한 도구입니다.스프링 클라우드는 여러 개의 마이크로서비스 애플리케이션을 개발하고 관리하기 위한 도구입니다.스프링 부트와 스프링 클라우드는 함께 사용되어 클라우드 환경에서 마이크로서비스 아키텍처를 구축할 수 있습니다.

스프링의 테스트(Test) 지원 기능은 어떤 것들이 있나요?

스프링은 다양한 테스트 지원 기능을 제공합니다.@RunWith(SpringRunner.class) 어노테이션을 사용하여 스프링 테스트 컨텍스트를 로드합니다.@ContextConfiguration 어노테이션을 사용하여 테스트에 필요한 빈을 설정할 수 있습니다.@Autowired 어노테이션을 사용하여 테스트 대상 객체를 주입받을 수 있습니다.@MockBean 어노테이션을 사용하여 목 객체를 생성하고 주입받을 수 있습니다.@Test 어노테이션을 사용하여 테스트 메서드를 정의하고 실행할 수 있습니다.

위의 질문과 답변은 스프링 관련 신입 개발자 면접에서 나올 수 있는 일부 내용을 다루고 있으며, 면접 상황에 따라 추가적인 질문이나 깊은 내용을 더 요구할 수 있습니다.

