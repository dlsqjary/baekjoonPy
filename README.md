인성질문
1.퇴사이유 : 원래부터 기술파트, R&D 부서에서 일하고 싶었고 SI가 잘 맞지 않는 것 같다고 느끼던 중에 연차 사용 관련해서 개인적으로 불만족스러운 여건이었음. 더 공부해보고 싶다는 생각도 있었기에 그때를 계기로 퇴사를 하게 됨.

2. 재입사 이유 : 퇴사하고 잠시 쉬고 다시 준비하려던 중 경제사정이 좋지 못하여 고민하다 다시 입사하게 됨.

3. 잘하는 것 / 관심있는 것...
웹 개발이랑은 관련없는데 아두이노를 활용해서 바른자세유지를 돕는 단말기를 만들 계획임.

4. 근무강도 : 정시퇴근이 힘들 수 있는데 괜찮은지? -> 괜찮음. 프로젝트도 수행하면서 야근하는 경우가 종종 있기 때문에 크게 상관X

5. 솔루션에 대한 내용
1) 모듈마다 다르긴 한데 가장 최신 업데이트가 5월11일로 알고 있음.
2) 솔루션 프로세스(구매프로세스)에 대해 하는가

6. R&D부서가 어떤 일을 하는 곳인지 아는지 
-> 프로젝트 수행 중이나 구축된 프로젝트에서 솔루션에 문제가 발견되거나 개선점이 파악되면 이를 수정하여 배포
-> 프로젝트 기술 지원
-> 최신기술 검토하여 솔루션에 적용

7. 지원사유
->입사했을 때부터 기술부에서 일하길 희망
->본인이 개발한 기능이 솔루션에 적용되어 사용되는 경험을 하길 희망함
->신입사원 교육때 원동명 책임님이 하신 말씀이 계속 기억에 남음: R&D팀은 수행팀, 기술지원팀에서 해결하지 못하는 것을 해결해야하는 부서다. 뒤가 없다. 라는 말이 멋있었고 그때부터 동경함.

8. R&D팀에 들어오면 개발해보고 싶은 것
->테스트간소화 도구(테스트데이터 자동입력)
->API문서 솔루션에 내재화
->소스 자동완성 기능

9. 지금까지 수행한 프로젝트
삼성물산건설, IBK시스템 EPRO구축, SOIL서버컨버전, GS리테일 구매포탈 인터페이스 변경

10. 개발하면서 문제가 있을 때 문제해결을 위해 어떻게 했는가?
->우선 로그, 에러 메세지 등을 분석하여 원인 파악 / 블로그, 온라인 문서 등을 통하여 관련 자료 검색 / 디버깅을 하며 프로그램 흐름을 체크하면서 문제 발생 원인 파악 + 문제 재현하며 원인 파악

11. 기억에 남는 프로젝트
-> IBK시스템 EPRO구축 / 보증보험 개발을 맡았는데 그 당시에 관련 지식도 부족하고 특정 공제조합과의 보증연계는 회사에서도 해본 사람이 많지 않아서 정보를 얻기가 힘들었음. 하지만 수많은 시행착오를 겪고 전공지식 등을 활용하면서 결국엔 개발을 끝마침.

12. 솔루션 개발하면서 아쉬웠던 점
원리를 모르고 사용하는 경우가 많다는게 아쉬움. 궁금할 때 소스를 따라가보면서 찾아보고는 있음.

궁금한 점
1. 부서에 들어가면 처음하게 될 업무는?
2. 오류나 개선사항이 발견되어 개발을 하고 테스트를 할 때 어떠한 환경에서 하는지?(환경을 동일하게 맞추고 하는지 데이터는 어떠한 방법으로 셋팅해서 넣는지)
3. 이번에 몇 명 정도 지원했는지, 결과는 언제 나오는지.
4. 10버전 개발에 R&D 인력이 얼마나 투입된건지.
5. 개발 환경이 어떻게 되는지(IDE 등..)



1. 객체지향 5원칙
객체지향 프로그래밍(OOP)에서는 다음과 같은 다섯 가지 원칙, 즉 SOLID 원칙을 따르는 것이 중요합니다:

SRP (단일 책임 원칙, Single Responsibility Principle): 하나의 클래스는 단 하나의 책임을 가져야 합니다. 클래스는 변경의 이유가 하나여야 하며, 하나의 책임을 수정하기 위한 이유로 클래스를 변경하는 것을 원칙으로 합니다.

OCP (개방 폐쇄 원칙, Open-Closed Principle): 확장에는 열려있고 변경에는 닫혀있어야 합니다. 기존의 코드를 수정하지 않고도 기능을 확장할 수 있도록 설계해야 합니다. 이를 위해 추상화, 인터페이스, 상속 등을 활용합니다.

LSP (리스코프 치환 원칙, Liskov Substitution Principle): 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 합니다. 즉, 상속 관계에서 부모 클래스의 역할을 자식 클래스가 무결하게 수행할 수 있어야 합니다.

ISP (인터페이스 분리 원칙, Interface Segregation Principle): 클라이언트는 자신이 사용하지 않는 인터페이스에 의존해서는 안 됩니다. 인터페이스는 클라이언트가 필요로 하는 기능에 따라 작게 분리되어야 합니다.

DIP (의존성 역전 원칙, Dependency Inversion Principle): 추상화에 의존해야 하며, 구체화에 의존해서는 안 됩니다. 고수준 모듈은 인터페이스나 추상 클래스와 의존성을 맺어야 하며, 저수준 모듈은 추상화된 것에 의존해야 합니다.

이러한 SOLID 원칙을 준수하면 코드는 유지보수가 용이하고 확장성이 높아지며, 재사용성과 테스트 용이성이 향상됩니다. 이외에도 객체지향 설계 원칙에는 캡슐화, 상속, 다형성 등이 있으며, 이들을 적절히 활용하여 유연하고 효율적인 객체지향 프로그램을 구축할 수 있습니다.

2. 자바의 특징
1)이식성: JVM을 통해 운영체제에 구애받지 않고 동작
2)객체지향: 코드의 모듈화, 재사용성, 유지보수성 증가
3)가바지 컬렉터로 사용하지 않는 객체를 메모리에서 제거
4)다양한 라이브러리 사용가능

3. 추상클래스와 인터페이스의 차이
1)추상클래스: 일부 메서드가 구현되어 있음. 상수 필드 사용 가능, 필드, 생성자, 일반 메서드를 가질 수 있음
2)인터페이스: 모든 메서드는 추상 메서드로 선언되어 있음. 상수필드 사용 불가. 클래스가 구현해야 하는 내용을 정의
기능의 관련성, 일관성 중요: 인터페이스
공통기능 구현 : 추상 클래스

4.자바의 예외 처리 방법
try-catch   / throws 문:메서드 선언부에 throws 키워드를 사용하여 메서드에서 발생할 수 있는 예외를 선언합니다.예외가 발생한 경우, 해당 메서드를 호출한 곳에서 예외를 처리하도록 요구됩니다.

5. 오버로딩 / 오버라이딩 차이
->오버로딩: 같은 이름을 가진 메서드 여러 개 정의 / 매개변수의 순서, 타입, 갯수가 다름 / 메서드를 유연하게 사용 
->오버라이딩: 상위 클래스에서 정의된 메서드를 하위 클래스에서 동일한 이름으로 사용하여 '재정의'

6. 프로세스와 스레드의 차이
->프로세스: 일을 처리함에 있어서의 하나의 단위. 각 프로세스는 독립적
->스레드: 프로세스 내에 실행되는 작업의 단위. 스레드는 데이터와 자원을 공유함.

7. 자바 컬렉션

8. Array와 List의 차이
->Array: 한번 생성되면 크기 조절 불가 / 동일한 데이터 타입으로 요소들이 구성됨 / 연속된 메모리 공간에 저장, 속도가 빠름
->List: 크기가 동적으로 조절됨(ArrayList, LinkedList) / 다양한 데이터 타입 사용 가능 / 요소들이 메모리의 임의의 위치에 저장

9. OOP(객체지향프로그래밍) 특징
->캡슐화: 코드를 캡슐화하여 정보 은닉하고 데이터 접근을 제어 / 유지보수, 재사용성 향상
->상속: 클래스 간 계층 구조를 사용하여 코드를 재사용하고 유지보수성 증대
->다형성: 동일한 메서드나 인터페이스를 다른 방식으로 구현하게 함 / 코드의 유형성과 확장성이 향상
->추상화: 불필요한 부분을 덜고 필요한 부분만 뽑아내어 클래스나 인터페이스에 필요 기능, 속성 적용

10. 자바의 접근 제어자
public
가장 넓은 범위를 가지는 접근 제어자입니다.public으로 선언된 클래스, 멤버 변수, 메서드는 어디서든 접근이 가능합니다.다른 클래스에서 해당 멤버에 자유롭게 접근할 수 있으므로, 공용 인터페이스를 제공하는 데 사용됩니다.

protected:
같은 패키지 내에서는 public과 동일한 접근 범위를 가지지만, 다른 패키지의 클래스에서는 상속 관계에 있는 경우에만 접근이 가능합니다.protected로 선언된 멤버 변수, 메서드는 자식 클래스에서 접근이 가능합니다.상속과 관련된 클래스의 확장성과 유연성을 위해 사용됩니다.

default (package-private):
접근 제어자를 명시적으로 지정하지 않은 경우의 기본 접근 제어자입니다.같은 패키지 내에서만 접근이 가능하며, 다른 패키지에서는 접근할 수 없습니다.패키지 내에서 구성 요소를 은닉하고, 모듈 내부의 세부 구현을 감추는 데 사용됩니다.

private
가장 제한적인 접근 범위를 가지는 접근 제어자입니다.private으로 선언된 멤버 변수, 메서드는 외부에서 직접 접근할 수 없습니다.해당 멤버는 클래스 내부에서만 사용되고, 정보 은닉과 캡슐화를 위해 사용됩니다.접근 제어자는 클래스와 멤버의 가시성을 조절하여 캡슐화와 정보 은닉을 지원합니다. 적절한 접근 제어자를 사용하여 코드의 가독성과 유지보수성을 높일 수 있습니다.


11. 자바의 제네릭
제네릭을 사용하면 타입에 대한 일반화와 재사용성을 통해 코드의 가독성과 유지보수성을 향상시킬 수 있습니다. 또한 컴파일러의 타입 체크 기능을 활용하여 타입 안정성을 강화할 수 있습니다.

제네릭 -   클래스나 메소드를 컴파일 시 타입체크를 해주는 기능 -   객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환을 생략 -   C lass   Box   같은 형식으로 사용(Box 는 제네릭 클래스,  T는 타입 변수,   Box는 원시 타입)   /   private   T   item ;    같이 사용 -   Class   Box   V>   이렇게 멀티 타입 파라미터 사용가능 -   제네릭 메서드를 정의할 때 제네릭 타입에 대한 정의를 반드시 명시해야 함.   /   제네릭 클래스와 같은 클래스의 제네릭 메서드에 같은 타입파라미터를 사용하도 상관없음 -   와일드카드 '? ’  모든 타입가능.  S uper   / extends를 사용하여 조상,   자손만 되게 설정 가능 


12. 클래스 패스/ 클래스 로더 차이
클래스 패스  -   자바를 실행할 때,   클래스의 위치를 지정하는 역할 /   자바 컴파일러는 클래스가 다른 곳으로 이동하면 찾을 수 없는데 이때 필요한 것이 클래스 패스이다 -   클래스패스는 사용하는 클래스가 여러 경로에 분산되어 있을 때 사용한다. -   코드를 컴파일 할 때 클래스패스에 있는 jre 설정이 잘 못되어 있어 컴파일이 되지 않았던 경험이 있음.     

클래스 로더 -   실행 시에 필요한 클래스를 동적으로 메모리에 로드하는 역할 -   기존에 생성된 클래스 객체가 메모리에 존재하는지 확인하고 있으면 객체의 참조를 반환,   없으면 클래스 패스에 지정된 경로를 따라서 클래스 파일을 찾는다. 

13. 클래스 / 객체 / 인스턴스 
클래스:   객체를 정의해 놓은 틀 /   객체들의 유사한 속성을 묶어 놓은 것 

객체:   실제로 존재하는 사물이나 개념( ex:  스마트폰 자동차)  /  프로그래밍 관점에선 클래스에 정의된 내용대로 메모리에 생성된 것 

인스턴스 -   클래스로부터 객체를 만드는 과정을 인스턴스화 라고 함 -   어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 함 -   객체는 모든 인스턴스를 대표하는 포괄적인 의미. 
-   인스턴스는 어떤 클래스로부터 만들어진 곳인지를 강조하는 구체적인 의미 

14. String, StringBuffer, StringBuilder 차이
->String: 한번 생성된 문자열 변경 불가. 변경될 때마다 메모리 용량 증대됨
->StringBuffer: 가변형, 문자열 동적으로 변경 가능 / 문자열 변경될 때 내부 버퍼에서 처리하여 메모리 세이브 / 멀티스레드 환경에서 동기화(synchronized)된 메서드를 제공하여 스레드 안전성을 보장합니다. 
-> StringBuilder: 동기화 부분 빼고 StringBuffer랑 동일



